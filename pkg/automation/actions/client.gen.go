// Package actions provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package actions

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/faetools/client"
)

// operation paths

const (
	opPathCompleteCallbackFormat              = "./automation/v4/actions/callbacks/%s/complete"
	opPathListAppFormat                       = "./automation/v4/actions/%s"
	opPathCreateAppFormat                     = "./automation/v4/actions/%s"
	opPathArchiveDefinitionFormat             = "./automation/v4/actions/%s/%s"
	opPathGetDefinitionFormat                 = "./automation/v4/actions/%s/%s"
	opPathUpdateDefinitionFormat              = "./automation/v4/actions/%s/%s"
	opPathListFunctionsFormat                 = "./automation/v4/actions/%s/%s/functions"
	opPathArchiveByFunctionTypeFormat         = "./automation/v4/actions/%s/%s/functions/%s"
	opPathGetByFunctionTypeFormat             = "./automation/v4/actions/%s/%s/functions/%s"
	opPathCreateOrReplaceByFunctionTypeFormat = "./automation/v4/actions/%s/%s/functions/%s"
	opPathArchiveFunctionFormat               = "./automation/v4/actions/%s/%s/functions/%s/%s"
	opPathGetFunctionFormat                   = "./automation/v4/actions/%s/%s/functions/%s/%s"
	opPathCreateOrReplaceFunctionFormat       = "./automation/v4/actions/%s/%s/functions/%s/%s"
	opPathListRevisionsFormat                 = "./automation/v4/actions/%s/%s/revisions"
	opPathGetRevisionFormat                   = "./automation/v4/actions/%s/%s/revisions/%s"
)

var opPathCompleteBatch = client.MustParseURL("./automation/v4/actions/callbacks/complete")

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// CompleteBatch request with any body
	CompleteBatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CompleteBatchResponse, error)
	CompleteBatch(ctx context.Context, body CompleteBatchJSONRequestBody, reqEditors ...client.RequestEditorFn) (*CompleteBatchResponse, error)

	// CompleteCallback request with any body
	CompleteCallbackWithBody(ctx context.Context, callbackId string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CompleteCallbackResponse, error)
	CompleteCallback(ctx context.Context, callbackId string, body CompleteCallbackJSONRequestBody, reqEditors ...client.RequestEditorFn) (*CompleteCallbackResponse, error)

	// ListApp request
	ListApp(ctx context.Context, appId int32, params *ListAppParams, reqEditors ...client.RequestEditorFn) (*ListAppResponse, error)

	// CreateApp request with any body
	CreateAppWithBody(ctx context.Context, appId int32, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateAppResponse, error)
	CreateApp(ctx context.Context, appId int32, body CreateAppJSONRequestBody, reqEditors ...client.RequestEditorFn) (*CreateAppResponse, error)

	// ArchiveDefinition request
	ArchiveDefinition(ctx context.Context, appId int32, definitionId string, reqEditors ...client.RequestEditorFn) (*ArchiveDefinitionResponse, error)

	// GetDefinition request
	GetDefinition(ctx context.Context, appId int32, definitionId string, params *GetDefinitionParams, reqEditors ...client.RequestEditorFn) (*GetDefinitionResponse, error)

	// UpdateDefinition request with any body
	UpdateDefinitionWithBody(ctx context.Context, appId int32, definitionId string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateDefinitionResponse, error)
	UpdateDefinition(ctx context.Context, appId int32, definitionId string, body UpdateDefinitionJSONRequestBody, reqEditors ...client.RequestEditorFn) (*UpdateDefinitionResponse, error)

	// ListFunctions request
	ListFunctions(ctx context.Context, appId int32, definitionId string, reqEditors ...client.RequestEditorFn) (*ListFunctionsResponse, error)

	// ArchiveByFunctionType request
	ArchiveByFunctionType(ctx context.Context, appId int32, definitionId string, functionType ArchiveByFunctionTypeParamsFunctionType, reqEditors ...client.RequestEditorFn) (*ArchiveByFunctionTypeResponse, error)

	// GetByFunctionType request
	GetByFunctionType(ctx context.Context, appId int32, definitionId string, functionType GetByFunctionTypeParamsFunctionType, reqEditors ...client.RequestEditorFn) (*GetByFunctionTypeResponse, error)

	// CreateOrReplaceByFunctionType request with any body
	CreateOrReplaceByFunctionTypeWithBody(ctx context.Context, appId int32, definitionId string, functionType CreateOrReplaceByFunctionTypeParamsFunctionType, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateOrReplaceByFunctionTypeResponse, error)

	// ArchiveFunction request
	ArchiveFunction(ctx context.Context, appId int32, definitionId string, functionType ArchiveFunctionParamsFunctionType, functionId string, reqEditors ...client.RequestEditorFn) (*ArchiveFunctionResponse, error)

	// GetFunction request
	GetFunction(ctx context.Context, appId int32, definitionId string, functionType GetFunctionParamsFunctionType, functionId string, reqEditors ...client.RequestEditorFn) (*GetFunctionResponse, error)

	// CreateOrReplaceFunction request with any body
	CreateOrReplaceFunctionWithBody(ctx context.Context, appId int32, definitionId string, functionType CreateOrReplaceFunctionParamsFunctionType, functionId string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateOrReplaceFunctionResponse, error)

	// ListRevisions request
	ListRevisions(ctx context.Context, appId int32, definitionId string, params *ListRevisionsParams, reqEditors ...client.RequestEditorFn) (*ListRevisionsResponse, error)

	// GetRevision request
	GetRevision(ctx context.Context, appId int32, definitionId string, revisionId string, reqEditors ...client.RequestEditorFn) (*GetRevisionResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// CompleteBatch: POST /automation/v4/actions/callbacks/complete

type CompleteBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CompleteBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompleteBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCompleteBatchRequestWithBody generates requests for CompleteBatch with any type of body
func newCompleteBatchRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCompleteBatch)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CompleteBatchWithBody request with arbitrary body returning *CompleteBatchResponse
func (c *Client) CompleteBatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CompleteBatchResponse, error) {
	rsp, err := c.doCompleteBatchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	return parseCompleteBatchResponse(rsp)
}

func (c *Client) doCompleteBatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*http.Response, error) {
	req, err := newCompleteBatchRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	return c.Client.Do(req)
}

func (c *Client) CompleteBatch(ctx context.Context, body CompleteBatchJSONRequestBody, reqEditors ...client.RequestEditorFn) (*CompleteBatchResponse, error) {
	rsp, err := c.doCompleteBatch(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	return parseCompleteBatchResponse(rsp)
}

// newCompleteBatchRequest calls the generic CompleteBatch builder with application/json body.
func newCompleteBatchRequest(baseURL *url.URL, body CompleteBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return newCompleteBatchRequestWithBody(baseURL, client.MIMEApplicationJSON, bodyReader)
}

func (c *Client) doCompleteBatch(ctx context.Context, body CompleteBatchJSONRequestBody, reqEditors ...client.RequestEditorFn) (*http.Response, error) {
	req, err := newCompleteBatchRequest(c.BaseURL, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	return c.Client.Do(req)
}

// parseCompleteBatchResponse parses an HTTP response from a CompleteBatch call.
func parseCompleteBatchResponse(rsp *http.Response) (*CompleteBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CompleteBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// CompleteCallback: POST /automation/v4/actions/callbacks/{callbackId}/complete

type CompleteCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CompleteCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompleteCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCompleteCallbackRequestWithBody generates requests for CompleteCallback with any type of body
func newCompleteCallbackRequestWithBody(baseURL *url.URL, callbackId string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("callbackId", callbackId)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCompleteCallbackFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CompleteCallbackWithBody request with arbitrary body returning *CompleteCallbackResponse
func (c *Client) CompleteCallbackWithBody(ctx context.Context, callbackId string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CompleteCallbackResponse, error) {
	rsp, err := c.doCompleteCallbackWithBody(ctx, callbackId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	return parseCompleteCallbackResponse(rsp)
}

func (c *Client) doCompleteCallbackWithBody(ctx context.Context, callbackId string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*http.Response, error) {
	req, err := newCompleteCallbackRequestWithBody(c.BaseURL, callbackId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	return c.Client.Do(req)
}

func (c *Client) CompleteCallback(ctx context.Context, callbackId string, body CompleteCallbackJSONRequestBody, reqEditors ...client.RequestEditorFn) (*CompleteCallbackResponse, error) {
	rsp, err := c.doCompleteCallback(ctx, callbackId, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	return parseCompleteCallbackResponse(rsp)
}

// newCompleteCallbackRequest calls the generic CompleteCallback builder with application/json body.
func newCompleteCallbackRequest(baseURL *url.URL, callbackId string, body CompleteCallbackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return newCompleteCallbackRequestWithBody(baseURL, callbackId, client.MIMEApplicationJSON, bodyReader)
}

func (c *Client) doCompleteCallback(ctx context.Context, callbackId string, body CompleteCallbackJSONRequestBody, reqEditors ...client.RequestEditorFn) (*http.Response, error) {
	req, err := newCompleteCallbackRequest(c.BaseURL, callbackId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	return c.Client.Do(req)
}

// parseCompleteCallbackResponse parses an HTTP response from a CompleteCallback call.
func parseCompleteCallbackResponse(rsp *http.Response) (*CompleteCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CompleteCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ListApp: GET /automation/v4/actions/{appId}

type ListAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollectionResponseExtensionActionDefinitionForwardPaging
}

// Status returns HTTPResponse.Status
func (r ListAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListAppRequest generates requests for ListApp
func newListAppRequest(baseURL *url.URL, appId int32, params *ListAppParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("appId", appId)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListAppFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Limit != nil {
		if err := client.AddQueryParam(q, "limit", *params.Limit); err != nil {
			return nil, err
		}
	}

	if params.After != nil {
		if err := client.AddQueryParam(q, "after", *params.After); err != nil {
			return nil, err
		}
	}

	if params.Archived != nil {
		if err := client.AddQueryParam(q, "archived", *params.Archived); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListApp request returning *ListAppResponse
func (c *Client) ListApp(ctx context.Context, appId int32, params *ListAppParams, reqEditors ...client.RequestEditorFn) (*ListAppResponse, error) {
	req, err := newListAppRequest(c.BaseURL, appId, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollectionResponseExtensionActionDefinitionForwardPaging
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateApp: POST /automation/v4/actions/{appId}

type CreateAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ExtensionActionDefinition
}

// Status returns HTTPResponse.Status
func (r CreateAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateAppRequestWithBody generates requests for CreateApp with any type of body
func newCreateAppRequestWithBody(baseURL *url.URL, appId int32, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("appId", appId)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateAppFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateAppWithBody request with arbitrary body returning *CreateAppResponse
func (c *Client) CreateAppWithBody(ctx context.Context, appId int32, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateAppResponse, error) {
	rsp, err := c.doCreateAppWithBody(ctx, appId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	return parseCreateAppResponse(rsp)
}

func (c *Client) doCreateAppWithBody(ctx context.Context, appId int32, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*http.Response, error) {
	req, err := newCreateAppRequestWithBody(c.BaseURL, appId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	return c.Client.Do(req)
}

func (c *Client) CreateApp(ctx context.Context, appId int32, body CreateAppJSONRequestBody, reqEditors ...client.RequestEditorFn) (*CreateAppResponse, error) {
	rsp, err := c.doCreateApp(ctx, appId, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	return parseCreateAppResponse(rsp)
}

// newCreateAppRequest calls the generic CreateApp builder with application/json body.
func newCreateAppRequest(baseURL *url.URL, appId int32, body CreateAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return newCreateAppRequestWithBody(baseURL, appId, client.MIMEApplicationJSON, bodyReader)
}

func (c *Client) doCreateApp(ctx context.Context, appId int32, body CreateAppJSONRequestBody, reqEditors ...client.RequestEditorFn) (*http.Response, error) {
	req, err := newCreateAppRequest(c.BaseURL, appId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	return c.Client.Do(req)
}

// parseCreateAppResponse parses an HTTP response from a CreateApp call.
func parseCreateAppResponse(rsp *http.Response) (*CreateAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ExtensionActionDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ArchiveDefinition: DELETE /automation/v4/actions/{appId}/{definitionId}

type ArchiveDefinitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ArchiveDefinitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveDefinitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newArchiveDefinitionRequest generates requests for ArchiveDefinition
func newArchiveDefinitionRequest(baseURL *url.URL, appId int32, definitionId string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("appId", appId)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("definitionId", definitionId)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathArchiveDefinitionFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ArchiveDefinition request returning *ArchiveDefinitionResponse
func (c *Client) ArchiveDefinition(ctx context.Context, appId int32, definitionId string, reqEditors ...client.RequestEditorFn) (*ArchiveDefinitionResponse, error) {
	req, err := newArchiveDefinitionRequest(c.BaseURL, appId, definitionId)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ArchiveDefinitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// GetDefinition: GET /automation/v4/actions/{appId}/{definitionId}

type GetDefinitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExtensionActionDefinition
}

// Status returns HTTPResponse.Status
func (r GetDefinitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefinitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newGetDefinitionRequest generates requests for GetDefinition
func newGetDefinitionRequest(baseURL *url.URL, appId int32, definitionId string, params *GetDefinitionParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("appId", appId)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("definitionId", definitionId)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathGetDefinitionFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Archived != nil {
		if err := client.AddQueryParam(q, "archived", *params.Archived); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// GetDefinition request returning *GetDefinitionResponse
func (c *Client) GetDefinition(ctx context.Context, appId int32, definitionId string, params *GetDefinitionParams, reqEditors ...client.RequestEditorFn) (*GetDefinitionResponse, error) {
	req, err := newGetDefinitionRequest(c.BaseURL, appId, definitionId, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &GetDefinitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExtensionActionDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateDefinition: PATCH /automation/v4/actions/{appId}/{definitionId}

type UpdateDefinitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExtensionActionDefinition
}

// Status returns HTTPResponse.Status
func (r UpdateDefinitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDefinitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateDefinitionRequestWithBody generates requests for UpdateDefinition with any type of body
func newUpdateDefinitionRequestWithBody(baseURL *url.URL, appId int32, definitionId string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("appId", appId)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("definitionId", definitionId)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateDefinitionFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPatch, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateDefinitionWithBody request with arbitrary body returning *UpdateDefinitionResponse
func (c *Client) UpdateDefinitionWithBody(ctx context.Context, appId int32, definitionId string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateDefinitionResponse, error) {
	rsp, err := c.doUpdateDefinitionWithBody(ctx, appId, definitionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	return parseUpdateDefinitionResponse(rsp)
}

func (c *Client) doUpdateDefinitionWithBody(ctx context.Context, appId int32, definitionId string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*http.Response, error) {
	req, err := newUpdateDefinitionRequestWithBody(c.BaseURL, appId, definitionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	return c.Client.Do(req)
}

func (c *Client) UpdateDefinition(ctx context.Context, appId int32, definitionId string, body UpdateDefinitionJSONRequestBody, reqEditors ...client.RequestEditorFn) (*UpdateDefinitionResponse, error) {
	rsp, err := c.doUpdateDefinition(ctx, appId, definitionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	return parseUpdateDefinitionResponse(rsp)
}

// newUpdateDefinitionRequest calls the generic UpdateDefinition builder with application/json body.
func newUpdateDefinitionRequest(baseURL *url.URL, appId int32, definitionId string, body UpdateDefinitionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return newUpdateDefinitionRequestWithBody(baseURL, appId, definitionId, client.MIMEApplicationJSON, bodyReader)
}

func (c *Client) doUpdateDefinition(ctx context.Context, appId int32, definitionId string, body UpdateDefinitionJSONRequestBody, reqEditors ...client.RequestEditorFn) (*http.Response, error) {
	req, err := newUpdateDefinitionRequest(c.BaseURL, appId, definitionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	return c.Client.Do(req)
}

// parseUpdateDefinitionResponse parses an HTTP response from a UpdateDefinition call.
func parseUpdateDefinitionResponse(rsp *http.Response) (*UpdateDefinitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateDefinitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExtensionActionDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListFunctions: GET /automation/v4/actions/{appId}/{definitionId}/functions

type ListFunctionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollectionResponseActionFunctionIdentifierNoPaging
}

// Status returns HTTPResponse.Status
func (r ListFunctionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFunctionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListFunctionsRequest generates requests for ListFunctions
func newListFunctionsRequest(baseURL *url.URL, appId int32, definitionId string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("appId", appId)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("definitionId", definitionId)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListFunctionsFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListFunctions request returning *ListFunctionsResponse
func (c *Client) ListFunctions(ctx context.Context, appId int32, definitionId string, reqEditors ...client.RequestEditorFn) (*ListFunctionsResponse, error) {
	req, err := newListFunctionsRequest(c.BaseURL, appId, definitionId)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListFunctionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollectionResponseActionFunctionIdentifierNoPaging
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ArchiveByFunctionType: DELETE /automation/v4/actions/{appId}/{definitionId}/functions/{functionType}

type ArchiveByFunctionTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ArchiveByFunctionTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveByFunctionTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newArchiveByFunctionTypeRequest generates requests for ArchiveByFunctionType
func newArchiveByFunctionTypeRequest(baseURL *url.URL, appId int32, definitionId string, functionType ArchiveByFunctionTypeParamsFunctionType) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("appId", appId)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("definitionId", definitionId)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("functionType", functionType)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathArchiveByFunctionTypeFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ArchiveByFunctionType request returning *ArchiveByFunctionTypeResponse
func (c *Client) ArchiveByFunctionType(ctx context.Context, appId int32, definitionId string, functionType ArchiveByFunctionTypeParamsFunctionType, reqEditors ...client.RequestEditorFn) (*ArchiveByFunctionTypeResponse, error) {
	req, err := newArchiveByFunctionTypeRequest(c.BaseURL, appId, definitionId, functionType)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ArchiveByFunctionTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// GetByFunctionType: GET /automation/v4/actions/{appId}/{definitionId}/functions/{functionType}

type GetByFunctionTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionFunction
}

// Status returns HTTPResponse.Status
func (r GetByFunctionTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetByFunctionTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newGetByFunctionTypeRequest generates requests for GetByFunctionType
func newGetByFunctionTypeRequest(baseURL *url.URL, appId int32, definitionId string, functionType GetByFunctionTypeParamsFunctionType) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("appId", appId)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("definitionId", definitionId)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("functionType", functionType)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathGetByFunctionTypeFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// GetByFunctionType request returning *GetByFunctionTypeResponse
func (c *Client) GetByFunctionType(ctx context.Context, appId int32, definitionId string, functionType GetByFunctionTypeParamsFunctionType, reqEditors ...client.RequestEditorFn) (*GetByFunctionTypeResponse, error) {
	req, err := newGetByFunctionTypeRequest(c.BaseURL, appId, definitionId, functionType)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &GetByFunctionTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionFunction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateOrReplaceByFunctionType: PUT /automation/v4/actions/{appId}/{definitionId}/functions/{functionType}

type CreateOrReplaceByFunctionTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionFunctionIdentifier
}

// Status returns HTTPResponse.Status
func (r CreateOrReplaceByFunctionTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrReplaceByFunctionTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateOrReplaceByFunctionTypeRequestWithBody generates requests for CreateOrReplaceByFunctionType with any type of body
func newCreateOrReplaceByFunctionTypeRequestWithBody(baseURL *url.URL, appId int32, definitionId string, functionType CreateOrReplaceByFunctionTypeParamsFunctionType, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("appId", appId)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("definitionId", definitionId)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("functionType", functionType)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateOrReplaceByFunctionTypeFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPut, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateOrReplaceByFunctionTypeWithBody request with arbitrary body returning *CreateOrReplaceByFunctionTypeResponse
func (c *Client) CreateOrReplaceByFunctionTypeWithBody(ctx context.Context, appId int32, definitionId string, functionType CreateOrReplaceByFunctionTypeParamsFunctionType, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateOrReplaceByFunctionTypeResponse, error) {
	req, err := newCreateOrReplaceByFunctionTypeRequestWithBody(c.BaseURL, appId, definitionId, functionType, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateOrReplaceByFunctionTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionFunctionIdentifier
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ArchiveFunction: DELETE /automation/v4/actions/{appId}/{definitionId}/functions/{functionType}/{functionId}

type ArchiveFunctionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ArchiveFunctionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveFunctionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newArchiveFunctionRequest generates requests for ArchiveFunction
func newArchiveFunctionRequest(baseURL *url.URL, appId int32, definitionId string, functionType ArchiveFunctionParamsFunctionType, functionId string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("appId", appId)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("definitionId", definitionId)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("functionType", functionType)
	if err != nil {
		return nil, err
	}

	pathParam3, err := client.GetPathParam("functionId", functionId)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathArchiveFunctionFormat, pathParam0, pathParam1, pathParam2, pathParam3)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ArchiveFunction request returning *ArchiveFunctionResponse
func (c *Client) ArchiveFunction(ctx context.Context, appId int32, definitionId string, functionType ArchiveFunctionParamsFunctionType, functionId string, reqEditors ...client.RequestEditorFn) (*ArchiveFunctionResponse, error) {
	req, err := newArchiveFunctionRequest(c.BaseURL, appId, definitionId, functionType, functionId)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ArchiveFunctionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// GetFunction: GET /automation/v4/actions/{appId}/{definitionId}/functions/{functionType}/{functionId}

type GetFunctionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionFunction
}

// Status returns HTTPResponse.Status
func (r GetFunctionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFunctionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newGetFunctionRequest generates requests for GetFunction
func newGetFunctionRequest(baseURL *url.URL, appId int32, definitionId string, functionType GetFunctionParamsFunctionType, functionId string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("appId", appId)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("definitionId", definitionId)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("functionType", functionType)
	if err != nil {
		return nil, err
	}

	pathParam3, err := client.GetPathParam("functionId", functionId)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathGetFunctionFormat, pathParam0, pathParam1, pathParam2, pathParam3)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// GetFunction request returning *GetFunctionResponse
func (c *Client) GetFunction(ctx context.Context, appId int32, definitionId string, functionType GetFunctionParamsFunctionType, functionId string, reqEditors ...client.RequestEditorFn) (*GetFunctionResponse, error) {
	req, err := newGetFunctionRequest(c.BaseURL, appId, definitionId, functionType, functionId)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &GetFunctionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionFunction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateOrReplaceFunction: PUT /automation/v4/actions/{appId}/{definitionId}/functions/{functionType}/{functionId}

type CreateOrReplaceFunctionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionFunctionIdentifier
}

// Status returns HTTPResponse.Status
func (r CreateOrReplaceFunctionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrReplaceFunctionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateOrReplaceFunctionRequestWithBody generates requests for CreateOrReplaceFunction with any type of body
func newCreateOrReplaceFunctionRequestWithBody(baseURL *url.URL, appId int32, definitionId string, functionType CreateOrReplaceFunctionParamsFunctionType, functionId string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("appId", appId)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("definitionId", definitionId)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("functionType", functionType)
	if err != nil {
		return nil, err
	}

	pathParam3, err := client.GetPathParam("functionId", functionId)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateOrReplaceFunctionFormat, pathParam0, pathParam1, pathParam2, pathParam3)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPut, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateOrReplaceFunctionWithBody request with arbitrary body returning *CreateOrReplaceFunctionResponse
func (c *Client) CreateOrReplaceFunctionWithBody(ctx context.Context, appId int32, definitionId string, functionType CreateOrReplaceFunctionParamsFunctionType, functionId string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateOrReplaceFunctionResponse, error) {
	req, err := newCreateOrReplaceFunctionRequestWithBody(c.BaseURL, appId, definitionId, functionType, functionId, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateOrReplaceFunctionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionFunctionIdentifier
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListRevisions: GET /automation/v4/actions/{appId}/{definitionId}/revisions

type ListRevisionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollectionResponseActionRevisionForwardPaging
}

// Status returns HTTPResponse.Status
func (r ListRevisionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRevisionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListRevisionsRequest generates requests for ListRevisions
func newListRevisionsRequest(baseURL *url.URL, appId int32, definitionId string, params *ListRevisionsParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("appId", appId)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("definitionId", definitionId)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListRevisionsFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Limit != nil {
		if err := client.AddQueryParam(q, "limit", *params.Limit); err != nil {
			return nil, err
		}
	}

	if params.After != nil {
		if err := client.AddQueryParam(q, "after", *params.After); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListRevisions request returning *ListRevisionsResponse
func (c *Client) ListRevisions(ctx context.Context, appId int32, definitionId string, params *ListRevisionsParams, reqEditors ...client.RequestEditorFn) (*ListRevisionsResponse, error) {
	req, err := newListRevisionsRequest(c.BaseURL, appId, definitionId, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListRevisionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollectionResponseActionRevisionForwardPaging
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// GetRevision: GET /automation/v4/actions/{appId}/{definitionId}/revisions/{revisionId}

type GetRevisionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionRevision
}

// Status returns HTTPResponse.Status
func (r GetRevisionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRevisionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newGetRevisionRequest generates requests for GetRevision
func newGetRevisionRequest(baseURL *url.URL, appId int32, definitionId string, revisionId string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("appId", appId)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("definitionId", definitionId)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("revisionId", revisionId)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathGetRevisionFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// GetRevision request returning *GetRevisionResponse
func (c *Client) GetRevision(ctx context.Context, appId int32, definitionId string, revisionId string, reqEditors ...client.RequestEditorFn) (*GetRevisionResponse, error) {
	req, err := newGetRevisionRequest(c.BaseURL, appId, definitionId, revisionId)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &GetRevisionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionRevision
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}
